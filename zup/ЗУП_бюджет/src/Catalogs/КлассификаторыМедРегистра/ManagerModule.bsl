#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Возвращает реквизиты справочника, которые образуют естественный ключ
//  для элементов справочника.
// Используется для сопоставления элементов механизмом «Выгрузка/загрузка областей данных».
//
// Возвращаемое значение: Массив(Строка) - массив имен реквизитов, образующих
//  естественный ключ.
//
Функция ПоляЕстественногоКлюча() Экспорт
	
	Результат = Новый Массив;
	
	Результат.Добавить("Код");
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПоставляемыеДанные

// Вызывается при получении уведомления о новых данных.
// В теле следует проверить, необходимы ли эти данные приложению, 
// и если да - установить флажок Загружать.
// 
// Параметры:
//   Дескриптор   - ОбъектXDTO -  Дескриптор.
//   Загружать    - булево - возвращаемое.
//
Процедура ДоступныНовыеДанные(Знач Дескриптор, Загружать) Экспорт
	
	Если Дескриптор.DataType = "КлассификаторыМедРегистра" Тогда
		Загружать = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Вызывается после вызова ДоступныНовыеДанные, позволяет разобрать данные.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO - Дескриптор.
//   ПутьКФайлу   - строка - Полное имя извлеченного файла. Файл будет автоматически удален 
//                  после завершения процедуры.
//
Процедура ОбработатьНовыеДанные(Знач Дескриптор, Знач ПутьКФайлу) Экспорт
	
	Если Не Дескриптор.DataType = "КлассификаторыМедРегистра" Тогда
		Возврат;
	КонецЕсли;
		
	// Разархивируем файл
	ПутьККаталогуНаСервере = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	СоздатьКаталог(ПутьККаталогуНаСервере);
	
	ЧтениеZIP = Новый ЧтениеZipФайла(ПутьКФайлу);
	ЧтениеZIP.ИзвлечьВсе(ПутьККаталогуНаСервере, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ЧтениеZIP.Закрыть();
	// Конец Разархивируем файл
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ
	|	КлассификаторыМедРегистра.Код КАК Код
	|ИЗ
	|	Справочник.КлассификаторыМедРегистра КАК КлассификаторыМедРегистра";
	
	ИменаКлассификаторов = Запрос.Выполнить().Выбрать();
	
	Пока ИменаКлассификаторов.Следующий() Цикл
		ЗагрузитьКлассификаторМедРегистраПоИмени(ИменаКлассификаторов.Код, ПутьККаталогуНаСервере);
	КонецЦикла;
		
КонецПроцедуры

// Вызывается при отмене обработки данных в случае сбоя.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO - Дескриптор.
//
Процедура ОбработкаДанныхОтменена(Знач Дескриптор) Экспорт 
КонецПроцедуры	

#КонецОбласти

#Область ЗагрузкаКлассификаторовМедРегистра

// Процедура загружает из внешнего архива ZIP в Справочник.
//
// Параметры:
//    ПараметрыЗагрузки - Структура - параметры для загрузки.
//    АдресХранилища    - Строка    - адрес внутреннего хранилища.
//
Процедура ЗагрузитьКлассификаторыМедРегистраИзАрхива(ПараметрыЗагрузки, АдресХранилища) Экспорт
		
	КодыКлассификаторов   = ПараметрыЗагрузки[0];	// Массив кодов регионов для загрузки.
	ОписаниеФайлов = ПараметрыЗагрузки[1];	// Массив структур описаний переданных файлов.
	
	// Создаем Временные Файлы
	// Извлекаем файлы, все имена файлов - в верхнем регистре.
	РабочийКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	СоздатьКаталог(РабочийКаталог);
	
	Описание = ОписаниеФайлов[0];
	// Имена файлов должны быть всегда в верхнем  регистре.
	Файл = Новый Файл(Описание.Имя);
	ИмяФайла = РабочийКаталог + ВРег(Файл.Имя);
	
	Данные = ?(ТипЗнч(Описание.Хранение) = Тип("Строка"), ПолучитьИзВременногоХранилища(Описание.Хранение), Описание.Хранение);
	Данные.Записать(ИмяФайла);
	
	// Распаковываем, оригинал удалится вместе с рабочим каталогом.
	ЧтениеZIP = Новый ЧтениеZipФайла(ИмяФайла);
	ЧтениеZIP.ИзвлечьВсе(РабочийКаталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ЧтениеZIP.Закрыть();
	
	ЗагрузитьКлассификаторыМедРегистраИзФайловВСправочник(КодыКлассификаторов, РабочийКаталог);
	
	РегистрыСведений.ХарактеристикиОбъектовПоМедРегистру.УстановитьХарактеристикиОбъектовПоКодамКлассификаторов(КодыКлассификаторов);

КонецПроцедуры

// Процедура загружает из внешних файлов в Справочник.
//
// Параметры:
//    ПараметрыЗагрузки - Структура - параметры для загрузки.
//    АдресХранилища    - Строка    - адрес внутреннего хранилища.
//
Процедура ЗагрузитьКлассификаторыМедРегистраИзКаталога(ПараметрыЗагрузки, АдресХранилища) Экспорт
		
	КодыКлассификаторов   = ПараметрыЗагрузки[0];	// Массив кодов регионов для загрузки.
	ОписаниеФайлов = ПараметрыЗагрузки[1];	// Массив структур описаний переданных файлов.
	
	// Создаем Временные Файлы
	// Извлекаем файлы, все имена файлов - в верхнем регистре.
	РабочийКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла());
	СоздатьКаталог(РабочийКаталог);
		
	Для Каждого Описание Из ОписаниеФайлов Цикл
		// Имена файлов должны быть всегда в верхнем  регистре.
		Файл = Новый Файл(Описание.Имя);
		ИмяФайла = РабочийКаталог + ВРег(Файл.Имя);
		
		Данные = ?(ТипЗнч(Описание.Хранение) = Тип("Строка"), ПолучитьИзВременногоХранилища(Описание.Хранение), Описание.Хранение);
		Данные.Записать(ИмяФайла);
		
	КонецЦикла;
	
	ЗагрузитьКлассификаторыМедРегистраИзФайловВСправочник(КодыКлассификаторов, РабочийКаталог);
	
	РегистрыСведений.ХарактеристикиОбъектовПоМедРегистру.УстановитьХарактеристикиОбъектовПоКодамКлассификаторов(КодыКлассификаторов);
	
КонецПроцедуры

// Процедура загружает из внешних файлов в Справочник.
//
// Параметры:
//    ПараметрыЗагрузки - Структура - параметры для загрузки.
//    АдресХранилища    - Строка    - адрес внутреннего хранилища.
//
Процедура ЗагрузитьКлассификаторыМедРегистраИзФайловВСправочник(КодыКлассификаторов, РабочийКаталог) 
	
	СообщениеПользователю = "";
	ЕстьОшибки = Ложь;
	
	Попытка
		
		Для Каждого КодОбъекта Из КодыКлассификаторов Цикл
			
			ИмяФайла = РабочийКаталог + ИмяУзлаПоНаименованиюКлассификатора(КодОбъекта) + ".xml";
    	    Файл = Новый Файл(ИмяФайла);
			
			Если Не Файл.Существует() Тогда
				
				СообщениеПользователю = 
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Файл не найден: %1.'"),
						Файл.Имя);
				
				ВызватьИсключение СообщениеПользователю; 
				
			КонецЕсли;
			
			ЗагрузитьКлассификаторМедРегистраПоИмени(КодОбъекта, РабочийКаталог);
			
		КонецЦикла;
		
	Исключение
		
		Информация = ИнформацияОбОшибке();
		СообщениеПользователю = ПодробноеПредставлениеОшибки(Информация);
		
		// Устанавливаем флаг для вызова исключения чтобы фоновое задание завершилось аварийно
		// и форма смогла обработать ошибку.
		ЕстьОшибки = Истина;
		
	КонецПопытки;
	
	// И чистим за собой
	Попытка
		УдалитьФайлы(РабочийКаталог);
	Исключение
		// Обработка не требуется, файлы будут удалены позднее.
	КонецПопытки;
	
	// Вызываем исключение чтобы фоновое задание завершилось аварийно
	// и форма смогла обработать ошибку.
	Если ЕстьОшибки Тогда
		
		ВызватьИсключение СообщениеПользователю;
		
	КонецЕсли;	
	
КонецПроцедуры

Функция ИмяУзлаПоНаименованиюКлассификатора(Наименование)
	
	Возврат СтрЗаменить(Наименование, "ArrayOf", "");
	
КонецФункции 

// Функция строит дерево значений из таблицы значений.
// Передаваемые параметры:
// ИсходнаяТаблица - таблица, которую следует преобразовать в дерево.
// 	* КолонкаID - строка - наименование колонки-идентификатора.
// 	* КолонкаParent - строка - наименование колонки-родителя.
// Возвращаемое значение
// Дерево значений.
//
Функция ДеревоИзТаблицы(ИсходнаяТаблица, КолонкаID="ID", КолонкаParent="Parent")
	
	ИсходнаяТаблица.Колонки.Добавить("ПолеСортировки", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10) ) );
	Для Каждого строка Из ИсходнаяТаблица Цикл
		строка.ПолеСортировки = Прав("00000"+СокрЛП(Строка[КолонкаParent]), 5);
	КонецЦикла;
	
	ИсходнаяТаблица.Сортировать("ПолеСортировки Возр");
	ДеревоРезультатов = Новый ДеревоЗначений; 
	Для Каждого КолонкаТбл Из ИсходнаяТаблица.Колонки Цикл
		Если КолонкаТбл.Имя = КолонкаParent Тогда
			Продолжить;
		КонецЕсли;
		ДеревоРезультатов.Колонки.Добавить(КолонкаТбл.Имя, КолонкаТбл.ТипЗначения);	
	КонецЦикла;
	
	Для Каждого ЭлТблЗначений Из ИсходнаяТаблица Цикл
		
		СтрокаРодитель = ДеревоРезультатов.Строки.Найти(ЭлТблЗначений[КолонкаParent], КолонкаID, Истина);
		Если СтрокаРодитель = Неопределено Тогда
			СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
		Иначе
			СтрокаДерева = СтрокаРодитель.Строки.Добавить();
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(СтрокаДерева, ЭлТблЗначений);

	КонецЦикла;
	
	// Еще раз пробежаться по таблице в ситуации когда Код родителя > кода элемента
	// тогда возможна ситуация с потерянными строками.
	Для Каждого ЭлТблЗначений Из ИсходнаяТаблица Цикл
		
		СтрокаРодитель = ДеревоРезультатов.Строки.Найти(ЭлТблЗначений[КолонкаParent], КолонкаID, Истина);
		СтрокаДерева    = ДеревоРезультатов.Строки.Найти(ЭлТблЗначений[КолонкаID], КолонкаID, Истина);
		
		Если СтрокаДерева = Неопределено Тогда
			
			СтрокаДерева = ДеревоРезультатов.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаДерева, ЭлТблЗначений);
			
		КонецЕсли; 
		
		Если Не СтрокаДерева.Родитель = СтрокаРодитель Тогда
			ЗаполнитьЗначенияСвойств(СтрокаРодитель.Строки.Добавить(), ЭлТблЗначений);
			ДеревоРезультатов.Строки.Удалить(СтрокаДерева);
		КонецЕсли;
		
	КонецЦикла;
	
   Возврат ДеревоРезультатов;
   
КонецФункции

Функция ОписаниеВозможныхПолейУзла()
	
	СтруктураКолонок = Новый Структура;	
	СтруктураКолонок.Вставить("ID"		,Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	СтруктураКолонок.Вставить("Name"	,Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(254)));
	СтруктураКолонок.Вставить("Parent"	,Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	СтруктураКолонок.Вставить("Order"	,Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	СтруктураКолонок.Вставить("OUZ"		,Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(254)));
	СтруктураКолонок.Вставить("KLADR"	,Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(13)));
   
	Возврат СтруктураКолонок;
	
КонецФункции	

// Читает XML КлассификатораМедРегистра в ТаблицуЗначения.
//
Функция ДанныеФайлаXMLКлассификатораМедРегистра(ИмяКлассификатора, ПутьКДаннымНаСервере)
	
	ИмяСвойства = ИмяУзлаПоНаименованиюКлассификатора(ИмяКлассификатора);
	ФайлКлассификатора = ПутьКДаннымНаСервере + ИмяСвойства + ".xml";
	
	ОписанияПолей = ОписаниеВозможныхПолейУзла(); 
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ФайлКлассификатора);
	
	ЧтениеXML.Прочитать();
	ИмяКлассификатораXML = ЧтениеXML.Имя;
	Если ЧтениеXML.Имя <> ИмяКлассификатора Тогда
		ЧтениеXML.Закрыть();
		Возврат -1;
	КонецЕсли;
	
	ДеревоXML = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	ЧтениеXML.Закрыть();
		
	УдалитьФайлы(ФайлКлассификатора);
	
	СвойстваОбъектаXDTO = ДеревоXML.Свойства();
	Если СвойстваОбъектаXDTO.Получить(ИмяСвойства) = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	СписокXDTO = ДеревоXML.ПолучитьСписок(ИмяСвойства);
	СвойстваОбъектаXDTO = СписокXDTO[0].Свойства();
	
	ДанныеФайлаXML = Новый ТаблицаЗначений;
	Для Каждого СвойствоСписка Из СвойстваОбъектаXDTO Цикл
		ИмяКолонки = СвойствоСписка.Имя;
		ТипКолонки = ОписанияПолей[ИмяКолонки];
		ДанныеФайлаXML.Колонки.Добавить(ИмяКолонки, ТипКолонки);
	КонецЦикла;
	
	Для Каждого ОбъектXDTO Из СписокXDTO Цикл
		ЗаполнитьЗначенияСвойств(ДанныеФайлаXML.Добавить(), ОбъектXDTO);
	КонецЦикла;
	
	Возврат ДанныеФайлаXML;

КонецФункции 

// Возвращает ссылку на элемент справочника.
//
Функция СохранитьЭлементСправочникЭлементыКлассификаторовМедРегистра(Данные, Владелец, Родитель, ЭтоГруппа)
	
	Если Данные.Наименование = Данные.НаименованиеЭлементаСправочника И ЗначениеЗаполнено(Данные.Ссылка) Тогда
		Возврат Данные.Ссылка;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Данные.Ссылка) Тогда
		
		ОбъектСправочника = Данные.Ссылка.ПолучитьОбъект();
		
	ИначеЕсли ЭтоГруппа Тогда
		
		ОбъектСправочника = Справочники.ЭлементыКлассификаторовМедРегистра.СоздатьГруппу();
		
	Иначе
		
		ОбъектСправочника = Справочники.ЭлементыКлассификаторовМедРегистра.СоздатьЭлемент();
		
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(ОбъектСправочника, Данные, "Код,Наименование");
	ОбъектСправочника.Родитель = Родитель;
	ОбъектСправочника.Владелец = Владелец;
	
	ОбъектСправочника.ОбменДанными.Загрузка = Истина;
	
	ОбъектСправочника.Записать();
	
	Возврат ОбъектСправочника.Ссылка;
	
КонецФункции

Процедура СохранитьИерархическиеДанныеСправочникЭлементыКлассификаторовМедРегистра(КоллекцияДанных, Владелец, Родитель)
	
	Для Каждого СтрокаДанных Из КоллекцияДанных Цикл
		
		ПодчиненныеСтроки = СтрокаДанных.Строки;
		ЭтоГруппа = ПодчиненныеСтроки.Количество()>0;
		
		Ссылка = СохранитьЭлементСправочникЭлементыКлассификаторовМедРегистра(СтрокаДанных, Владелец, Родитель, ЭтоГруппа);
		
		Если ЭтоГруппа Тогда
			
			СохранитьИерархическиеДанныеСправочникЭлементыКлассификаторовМедРегистра(ПодчиненныеСтроки, Владелец, Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Переносим значения из таблицы в Справочник.
Процедура СохранитьДанныеВСправочникЭлементыКлассификаторовМедРегистра(ТаблицаДанных, Владелец, Родитель, ЕстьИерархия)

	Запрос = Новый Запрос;
	
	Если ЕстьИерархия Тогда
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.ID КАК Код,
		|	Таблица.Name КАК Наименование,
		|	Таблица.Parent КАК Родитель
		|ПОМЕСТИТЬ ВТТаблица
		|ИЗ
		|	&ТЗ КАК Таблица";
		
	Иначе
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.ID КАК Код,
		|	Таблица.Name КАК Наименование,
		|	Выразить("""" КАК Строка(10)) КАК Родитель
		|ПОМЕСТИТЬ ВТТаблица
		|ИЗ
		|	&ТЗ КАК Таблица";
		
	КонецЕсли;	
	
	ТекстЗапроса = ТекстЗапроса + "
	|;
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.Код,
	|	Таблица.Наименование,
	|	Таблица.Родитель,
	|	Таблица.КоличествоПодчиненных,
	|	ЕСТЬNULL(ЭлементыСправочника.Ссылка, ЗНАЧЕНИЕ(Справочник.ЭлементыКлассификаторовМедРегистра.ПустаяСсылка)) КАК Ссылка,
	|	ЕСТЬNULL(ЭлементыСправочника.Наименование, Выразить("""" КАК Строка(150))) КАК НаименованиеЭлементаСправочника
	|ИЗ
	|	(ВЫБРАТЬ
	|		Таблица.Код КАК Код,
	|		Таблица.Наименование КАК Наименование,
	|		Таблица.Родитель КАК Родитель,
	|		КОЛИЧЕСТВО(ТаблицаПодчиненных.Код) КАК КоличествоПодчиненных
	|	ИЗ
	|		ВТТаблица КАК Таблица
	|			ЛЕВОЕ СОЕДИНЕНИЕ ВТТаблица КАК ТаблицаПодчиненных
	|			ПО Таблица.Код = ТаблицаПодчиненных.Родитель
	|	
	|	СГРУППИРОВАТЬ ПО
	|		Таблица.Код,
	|		Таблица.Наименование,
	|		Таблица.Родитель) КАК Таблица
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ЭлементыКлассификаторовМедРегистра КАК ЭлементыСправочника
	|		ПО (ЭлементыСправочника.Владелец = &Владелец)
	|			И (ЭлементыСправочника.Код = Таблица.Код)";
	
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Владелец", Владелец);
	Запрос.УстановитьПараметр("ТЗ", ТаблицаДанных);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если ЕстьИерархия Тогда
		
		ДеревоЗначений = ДеревоИзТаблицы(РезультатЗапроса.Выгрузить(), "Код", "Родитель");
		
		СохранитьИерархическиеДанныеСправочникЭлементыКлассификаторовМедРегистра(ДеревоЗначений.Строки, Владелец, Справочники.ЭлементыКлассификаторовМедРегистра.ПустаяСсылка());
		
	Иначе
		
		Выборка = РезультатЗапроса.Выбрать();
		Пока выборка.Следующий() Цикл
			
			СохранитьЭлементСправочникЭлементыКлассификаторовМедРегистра(Выборка, Владелец, Родитель, Ложь);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Загружает Данные из xml в справочник "ЭлементыКлассификаторовМедРегистра".
//
Функция ЗагрузитьКлассификаторМедРегистраПоИмени(ИмяКлассификатора, ПутьКДаннымНаСервере)
	
	// Читаем xml
	ДанныеФайлаXML = ДанныеФайлаXMLКлассификатораМедРегистра(ИмяКлассификатора, ПутьКДаннымНаСервере);
	
	// Сохраняем значения
	ЕстьИерархия = ДанныеФайлаXML.Колонки.Найти("Parent") <> Неопределено;
	Родитель = Неопределено;
	Владелец = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.КлассификаторыМедРегистра." + ИмяКлассификатора);
	
	СохранитьДанныеВСправочникЭлементыКлассификаторовМедРегистра(ДанныеФайлаXML, Владелец, Родитель, ЕстьИерархия);
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

// Определяет возможность выбора из классификатора групп и элементов.
//
// Параметры:
//   Классификатор - СправочникСсылка.КлассификаторыМедРегистра.
//
// Возвращаемое значение:
//   Булево - Истина, если классификатор входит в список классификаторов,
//   для которых использование групп и элементов разрешено.
//
Функция КлассификаторИспользуетВыборГруппИЭлементов(Классификатор) Экспорт
	
	МассивКлассификаторов = Новый Массив();
	МассивКлассификаторов.Добавить(Справочники.КлассификаторыМедРегистра.ArrayOfCertificateSpeciality);
	
	Возврат МассивКлассификаторов.Найти(Классификатор) <> Неопределено;
	
КонецФункции

#КонецОбласти

#КонецЕсли